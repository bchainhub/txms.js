#!/usr/bin/env node

import { mkdirSync, readFileSync, existsSync } from 'fs';
import { fileURLToPath } from 'url';
import path from 'path';
import txms from '../dist/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Helper function to parse command-line arguments with key-value pairs
function parseArgs(argv) {
	const args = {
		kind: null, // The type of operation to perform
		value: null, // This will hold the hex data for encode/decode
		output: null, // For download output directory
		filename: null, // For download filename
		countryCodes: null, // For getEndpoint
		phoneNumbers: null, // For SMS/MMS phone numbers
		download: false, // Flag to indicate download
	};

	argv.forEach((arg) => {
		if (arg.startsWith('--')) {
			const [key, value] = arg.split('=');
			switch (key) {
				case '--version':
					args.kind = 'version';
					break;
				case '--encode':
					args.kind = 'encode';
					args.value = value;
					break;
				case '--decode':
					args.kind = 'decode';
					args.value = value;
					break;
				case '--getendpoint':
					args.kind = 'getendpoint';
					args.value = value; // Network type for getEndpoint
					break;
				case '--sms':
					args.kind = 'sms';
					args.phoneNumbers = value; // Comma-separated phone numbers
					break;
				case '--mms':
					args.kind = 'mms';
					args.phoneNumbers = value; // Comma-separated phone numbers
					break;
				case '--download':
					args.download = true;
					break;
				case '--output':
					args.output = value;
					break;
				case '--filename':
					args.filename = value;
					break;
				case '--countries':
					args.countryCodes = value.split(','); // Comma-separated country codes
					break;
				default:
					break;
			}
		} else if (arg.startsWith('-')) {
			const [key, value] = arg.split('=');
			switch (key) {
				case '-v':
					args.kind = 'version';
					break;
				case '-e':
					args.kind = 'encode';
					args.value = value;
					break;
				case '-d':
					args.kind = 'decode';
					args.value = value;
					break;
				case '-g':
					args.kind = 'getendpoint';
					args.value = value;
					break;
				case '-s':
					args.kind = 'sms';
					args.phoneNumbers = value;
					break;
				case '-m':
					args.kind = 'mms';
					args.phoneNumbers = value;
					break;
				case '-o':
					args.output = value;
					break;
				case '-f':
					args.filename = value;
					break;
				case '-c':
					args.countryCodes = value.split(',');
					break;
				default:
					break;
			}
		} else {
			if (!args.value) {
				args.value = arg;
			}
		}
	});
	return args;
}

// Parse the arguments
const args = parseArgs(process.argv.slice(2));

if (process.stdin.isTTY) {
	// If the script is run with a TTY, process the command-line arguments
	run(args.kind, args.value, args.output, args.countryCodes, args.phoneNumbers, args.download, args.filename);
} else {
	// If data is being piped into the script, capture it
	let content = '';
	process.stdin.setEncoding('utf8');
	process.stdin.on('data', (buf) => {
		content += buf.toString();
	});
	process.stdin.on('end', () => {
		content = content.trim();

		if (!content) {
			run(args.kind, args.value, args.output, args.countryCodes, args.phoneNumbers, args.download, args.filename);
		} else {
			run(args.kind, content, args.output, args.countryCodes, args.phoneNumbers, args.download, args.filename);
		}
	});
}

async function run(kind, value, output, countryCodes, phoneNumbers, download, filename) {
	if (!value && kind !== 'version') {
		process.stderr.write('Value is required\n');
		process.exit(1);
	}

	try {
		if (download && output && !existsSync(output)) {
			mkdirSync(output, { recursive: true });
		}

		if (kind === 'version' || kind === 'v') {
			const packageJsonPath = path.join(__dirname, '../package.json');
			const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
			const version = packageJson.version;
			process.stdout.write(version);
			process.exit(0);
		} else if (kind === 'encode' || kind === 'e') {
			if (download) {
				const filenm = await txms.downloadMessage(value, filename ? filename : undefined, output);
				process.stdout.write(`TxMS file was downloaded as "${filenm}".\n`);
			} else {
				const encoded = txms.encode(value);
				process.stdout.write(encoded);
			}
			process.exit(0);
		} else if (kind === 'decode' || kind === 'd') {
			const decoded = txms.decode(value);
			process.stdout.write(decoded);
			process.exit(0);
		} else if (kind === 'getendpoint' || kind === 'g') {
			const endpoint = txms.getEndpoint(value, countryCodes);
			let endpointString = Object.keys(endpoint).map(key => {
				const numbers = endpoint[key].join(',');
				return `${key}:${numbers}`;
			}).join(';');
			process.stdout.write(endpointString);
			process.exit(0);
		} else if (kind === 'sms') {
			const message = txms.encode(value);
			const sms = txms.sms(phoneNumbers ? phoneNumbers.split(',') : true, message);
			process.stdout.write(sms);
			process.exit(0);
		} else if (kind === 'mms') {
			const message = txms.encode(value);
			const mms = txms.mms(phoneNumbers ? phoneNumbers.split(',') : true, message);
			process.stdout.write(mms);
			process.exit(0);
		} else {
			throw new Error('Invalid type specified.');
		}
	} catch (err) {
		process.stderr.write(`${err.message}\n`);
		process.exit(1);
	}
}
